[bits 16]
FUNCOFFSET equ 0x8000		;
FUNCSEG equ 0x0800
	
main:
	cli			;
	mov ax, 0x9000		;
	mov ss, ax		;
	mov bp, 0x0000		;
	mov sp, bp		;
	sti			;
	mov ax, 0x7c0		;
	mov ds, ax		;

	;; load 2 sectors to 0x0000:FUNCOFFSET
	mov ax, 0		;
	mov es, ax		;
	mov byte[BOOT_DRIVE],dl ;
	mov bx, FUNCOFFSET	;
	mov dh, 2		;
	call loadDisk		;
	mov si, LOAD_MSG-main	;
	call printString_1	;
jump:
	jmp FUNCSEG:0x0000	;
	mov ah,0x0e		;
	mov al,'X'		;
	int 0x10		;
	jmp jump		;

loadDisk:
	push dx			;
	mov ah, 0x02		;
	mov al, dh		;
	mov ch, 0x00		;
	mov dh, 0x00		;
	mov cl, 0x02		;
	int 0x13		;
	jc .disk_error		;
	pop dx			;
	cmp dh, al		;
	jne .disk_error		;
	ret			;
	.disk_error:
	mov si, DISK_ERROR_MSG-main	;
	call printString_1	;
	jmp $			;
	
printString_1:
	pusha			;
	mov ah, 0x0e		;
	.loop:
	mov al, [ds:si]		;
	cmp al, 0		;
	je .return		;
	int 0x10		;
	inc si			;
	jmp .loop		;
	.return:
	popa			;
	ret			;

BOOT_DRIVE db 0			;
LOAD_MSG db 'Code loading.',0	;
DISK_ERROR_MSG db 'Disk error.',0 ;
times 510-($-$$) db 0		;
dw 0xaa55			;

;;; Here starts 2 & 3 sector
function_start:
	mov ax, cs		;
	mov ds, ax		;
	mov si, CODE_MSG-function_start;
	call printString	;
	call field		;
	jmp $			;
field:
	call reset		;
	mov ax, 0xb800		;
	mov es, ax		;

	;; set timer routine
	cli			;
	push ds			;
	mov ax, 0x0000		;
	mov ds, ax		;
	mov bx, 0x1c*4		;
	mov word[bx], clockRoutine-function_start;
	mov ax, cs		   ;
	mov word[bx+2], ax	   ;
	pop ds			   ;
	sti			   ;
	;;
	;; show a random apple
	call showRandApple	;
	;; 
	mov ax, word[snakebox-function_start]	;
	mov bx, 0		;
	mov word[es:bx], ax 	;
	.loop:
	cmp byte[status-function_start], 0	       ;
	je .reset		;
	mov ah, 0x00		; read a character
	int 0x16		;
	cmp al, 'd'		;
	je .store		;
	cmp al, 'w'		;
	je .store		;
	cmp al, 'a'		;
	je .store		;
	cmp al, 's'		;
	je .store		;
	jmp .loop		;
	.store:
	mov byte[direction-function_start], al	;
	jmp .loop		;
	.reset:
	mov ah, 0x00		;
	int 0x16		;
	cmp al, 'r'		;
	jne .reset		;
	call reset		;
	jmp .loop		;
	ret			;
clockRoutine:
	mov ax, cs		;
	mov ds, ax		;
	mov al, byte[delay-function_start]	;
	cmp byte[timer-function_start], al	;
	je .next		;
	inc byte[timer-function_start]		;
	iret			;
	.next:
	call snake		;
	iret			;
snake:	
	cmp byte[status-function_start], 1    ;
	jne .return			      ;
	mov ax, word[applePos-function_start]	;
	mov bx, word[pos-function_start]	;
	cmp ax, bx		;
	jne .move		;
	inc word[appleNum-function_start]	;
	call showRandApple	;
	mov ax, word[appleNum-function_start]	;
	mov dx, 0		;
	mov cx, 5		;
	div cx			;
	cmp dx, 0		;
	jne .move		;
	dec byte[delay-function_start]		;
	cmp byte[delay-function_start], 0	;
	jne .move		;
	mov byte[delay-function_start], 1	;
	.move:
	mov byte[timer-function_start], 0	;
	mov al, byte[direction-function_start]	;
	cmp al, 'd'		;
	je .right		;
	cmp al, 'w'		;
	je .up			;
	cmp al, 'a'		;
	je .left		;
	cmp al, 's'		;
	je .down		;
	ret			;
	.right:
	call moveright		;
	ret			;
	.up:
	call moveup		;
	ret			;
	.left:
	call moveleft		;
	ret			;
	.down:
	call movedown		;
	ret			;
	.return:
	ret			;
cls:
	pusha			;
	mov ax, 0xb800		;
	mov es, ax		;
	mov bx, 0		;
	.loop:
	cmp bx, 4000		;
	jz .return		;
	mov ax, word[backgroundbox-function_start];
	mov word[es:bx], ax	;
	add bx, 2		;
	jmp .loop		;
	.return:
	popa			;
	ret			;

showRandApple:
	pusha			;
	mov ax, 0xb800		;
	mov es, ax		;

	.loop:
	call rand		;
	mov ax, cx		;
	mov dx, 0		;
	mov cx, 80		;
	div cx			;
	mov bx, dx		;
	call rand		;
	mov ax, cx		;
	mov dx, 0		;
	mov cx, 25		;
	div cx			;
	mov ax, dx		;

	mov cx, 80		;
	mul cx			;
	add ax, bx		;
	mov cx, 2		;
	mul cx			;
	mov bx, ax		;
	mov ax, word[pos-function_start]	;
	cmp ax, bx		;
	je .loop		;
	
	mov ax, word[applebox-function_start];
	mov word[es:bx], ax;
	mov word[applePos-function_start], bx	; store current apple position
	
	popa			;
	ret			;
	
rand:
	;; r_k = (multiplier*r_k-1 + increment) mod modulus
	;; r_k-1 is stored in [seed]
	;; modulus=65535, multiplier=31821, increment=13849
	;; result range (0-cx)
	;; return value in cx
	push ax			;
	push bx			;
	push dx			;
	mov ah, 0x00		; read time
	int 0x1a		;
	mov word[seed-function_start], dx	;
	mov ax, 31821		;
	mul word[seed-function_start]	;
	add ax, 13849		;

	mov word[seed-function_start], ax	;
	mov cx, ax				;
	pop dx			;
	pop bx			;
	pop ax			;
	ret			;

gameover:
	cmp byte[status-function_start], 1  ;
	jne .return			    ;
	mov si, GAMEOVER_MSG-function_start;
	call printString		   ;
	mov byte[status-function_start], 0 ;
	.return:
	ret			;
reset:
	call cls				;
	;; set cursor position
	mov ah, 0x02				;
	mov bh, 0				;
	mov dh, 10				;
	mov dl, 20				;
	int 0x10				;
	;; reset variables
	mov word[seed-function_start], 0 ;
	mov word[applePos-function_start], 0	     ;
	mov word[appleNum-function_start], 0	     ;
	mov byte[timer-function_start], 0	     ;
	mov byte[delay-function_start], 2	     ;
	mov byte[direction-function_start], 'd'     ;
	mov word[pos-function_start], 0	     ;
	mov byte[status-function_start], 1   ;
	ret			     ;
moveup:
	;; move box located in [es:bx] upward
	;; set bx as current pos
	pusha			;
	mov bx, word[pos-function_start]	;
	mov ax, 0xb800		;
	mov es, ax		;
	mov ax, word[backgroundbox-function_start]	;
	mov word[es:bx], ax	;
	cmp bx, 160		;
	jge .next		;
	add bx, 160		;
	call gameover		;
	jmp .over		;
	.next:
	sub bx, 160		;
	mov ax, word[snakebox-function_start]	;
	mov word[es:bx],ax	;
	mov word[pos-function_start], bx	;
	.over:
	popa			;
	ret			;
	
movedown:
	;; move box located in [es:bx] downward
	;; set bx as current pos
	pusha			;
	mov bx, word[pos-function_start]	;
	mov ax, 0xb800		;
	mov es, ax		;
	mov ax, word[backgroundbox-function_start]	;
	mov word[es:bx], ax	;
	add bx, 160		;
	cmp bx, 4000		;
	jl .next		;
	sub bx, 160		;
	call gameover		;
	jmp .over		;
	.next:
	mov ax, word[snakebox-function_start]	;
	mov word[es:bx],ax	;
	mov word[pos-function_start], bx	;
	.over:
	popa			;
	ret			;

moveleft:
	;; move box located in [es:bx] leftward
	;; set bx as current pos
	pusha			;
	mov bx, word[pos-function_start]	;
	mov ax, 0xb800		;
	mov es, ax		;
	mov ax, word[backgroundbox-function_start]	;
	mov word[es:bx], ax	;
	mov dx, 0		;
	mov ax, bx		;
	mov cx, 160		;
	div cx			;
	cmp dx, 0		;
	jne .next		;
	add bx, 2		;
	call gameover		;
	jmp .over		;
	.next:
	sub bx, 2		;
	mov ax, word[snakebox-function_start]	;
	mov word[es:bx],ax	;
	mov word[pos-function_start], bx	;
	.over:
	popa			;
	ret			;

moveright:
	;; move box located in [es:bx] rightward
	;; set bx as current pos
	pusha;
	mov bx, word[pos-function_start]	;
	mov ax, 0xb800		;
	mov es, ax		;
	mov ax, word[backgroundbox-function_start]	;
	mov word[es:bx], ax	;
	mov dx, 0		;
	mov ax, bx		;
	mov cx, 160		;
	div cx			;
	cmp dx, 158		;
	je .over		;
	add bx, 2		;
	mov ax, word[snakebox-function_start]	;
	mov word[es:bx],ax	;
	mov word[pos-function_start], bx	;
	popa			;
	ret			;
	.over:
	call gameover		;
	popa			;
	ret			;
	
printString:
	pusha			;
	mov ah, 0x0e		;
	.loop:
	mov al, [ds:si]		;
	cmp al, 0		;
	je .return		;
	int 0x10		;
	inc si			;
	jmp .loop		;
	.return:
	popa			;
	ret			;

seed dw 0			;
applePos dw 0			;
appleNum dw 0			;
	
fruitbox dw 0xcc20	;
snakebox dw 0x1120		;
backgroundbox dw 0x7020		;
timer db 0			;
delay db 2			;
direction db 'd'		; d:right, w:up, a:left, s:down
pos dw 0			; current position
status db 0			;

GAMEOVER_MSG db "Game Over!(Double press 'r' to try again)",0	;
CODE_MSG db 'Now in Code sector.',0	;
times 1024-($-function_start) db 0		;
